<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5FRS651E26"></script>
  <script> window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'G-5FRS651E26'); </script>
  <title>Living Hinge Designer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useCallback, useEffect } = React;

    function LivingHingeGenerator() {
      const [dimensions, setDimensions] = useState({ length: 100, width: 50 });
      const [laserType, setLaserType] = useState('diode');
      const [units, setUnits] = useState('mm');
      const [advancedSettings, setAdvancedSettings] = useState({
        bridgeWidth: 2.5,
        rowSpacing: 1.5,
        cutLength: 25.4,
        kerfWidth: 0.1,
        edgeOverhang: 1.0
      });
      const [showAdvanced, setShowAdvanced] = useState(false);
      const [zoomLevel, setZoomLevel] = useState(2);
      const [lengthInput, setLengthInput] = useState('100');
      const [widthInput, setWidthInput] = useState('50');
      const [bridgeWidthInput, setBridgeWidthInput] = useState('2.5');
      const [rowSpacingInput, setRowSpacingInput] = useState('1.5');
      const [cutLengthInput, setCutLengthInput] = useState('25.4');
      const [kerfWidthInput, setKerfWidthInput] = useState('0.1');
      const [edgeOverhangInput, setEdgeOverhangInput] = useState('1.0');

      const resetToDefaults = () => {
        setDimensions({ length: 100, width: 50 });
        setLaserType('diode');
        setUnits('mm');
        setAdvancedSettings({
          bridgeWidth: 2.5,
          rowSpacing: 1.5,
          cutLength: 25.4,
          kerfWidth: 0.1,
          edgeOverhang: 1.0
        });
        setLengthInput('100');
        setWidthInput('50');
        setBridgeWidthInput('2.5');
        setRowSpacingInput('1.5');
        setCutLengthInput('25.4');
        setKerfWidthInput('0.1');
        setEdgeOverhangInput('1.0');
        setZoomLevel(2);
      };

      const convertToMm = (value) => units === 'inches' ? value * 25.4 : value;
      const convertFromMm = (value) => units === 'inches' ? value / 25.4 : value;
      const formatUnit = (value) => units === 'inches' ? value.toFixed(3) : value.toFixed(1);
      const getStepSize = () => units === 'inches' ? 0.01 : 0.1;

      useEffect(() => {
        const defaultKerf = laserType === 'co2' ? 0.3 : 0.1;
        const defaultRowSpacing = laserType === 'co2' ? 1.8 : 1.5;
        setAdvancedSettings(prev => ({ ...prev, kerfWidth: defaultKerf, rowSpacing: defaultRowSpacing }));
        setKerfWidthInput(defaultKerf.toString());
        setRowSpacingInput(defaultRowSpacing.toString());
      }, [laserType]);

      useEffect(() => {
        setLengthInput(formatUnit(convertFromMm(dimensions.length)));
        setWidthInput(formatUnit(convertFromMm(dimensions.width)));
        setBridgeWidthInput(formatUnit(convertFromMm(advancedSettings.bridgeWidth)));
        setRowSpacingInput(formatUnit(convertFromMm(advancedSettings.rowSpacing)));
        setCutLengthInput(formatUnit(convertFromMm(advancedSettings.cutLength)));
        setKerfWidthInput(formatUnit(convertFromMm(advancedSettings.kerfWidth)));
        setEdgeOverhangInput(formatUnit(convertFromMm(advancedSettings.edgeOverhang)));
      }, [units]);

      const generateSVG = useCallback(() => {
        const { length, width } = dimensions;
        const { bridgeWidth, rowSpacing, cutLength, kerfWidth, edgeOverhang } = advancedSettings;
        const numRows = Math.floor(length / rowSpacing);

        let svg = '<?xml version="1.0" encoding="UTF-8"?>\n';
        svg += '<svg width="' + width + 'mm" height="' + length + 'mm" viewBox="0 0 ' + width + ' ' + length + '" xmlns="http://www.w3.org/2000/svg">\n';
        svg += '  <defs><style>.cut-line { stroke: rgb(255,0,0); stroke-width: ' + kerfWidth + '; fill: none; }</style></defs>\n';
        svg += '  <g id="living-hinge-pattern">\n';

        const cutPlusBridge = cutLength + bridgeWidth;
        const numCompleteUnits = Math.floor(width / cutPlusBridge);
        const totalCompleteWidth = numCompleteUnits * cutPlusBridge;
        const centerOffset = (width - totalCompleteWidth) / 2;
        const trimLeft = -edgeOverhang;
        const trimRight = width + edgeOverhang;

        for (let row = 0; row < numRows; row++) {
          const y = row * rowSpacing;
          const isEvenRow = row % 2 === 0;
          const brickOffset = isEvenRow ? 0 : cutPlusBridge / 2;
          const startX = centerOffset + brickOffset;

          for (let x = startX - cutPlusBridge; x < width + cutPlusBridge; x += cutPlusBridge) {
            let x1 = Math.max(x, trimLeft);
            let x2 = Math.min(x + cutLength, trimRight);
            if (x2 > trimLeft && x1 < trimRight && x2 - x1 > 0.1) {
              svg += '    <line x1="' + x1 + '" y1="' + y + '" x2="' + x2 + '" y2="' + y + '" class="cut-line" />\n';
            }
          }
        }

        svg += '  </g>\n</svg>';
        return svg;
      }, [dimensions, advancedSettings]);

      const downloadSVG = () => {
        const svgContent = generateSVG();
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'living-hinge-' + dimensions.width + 'x' + dimensions.length + 'mm.svg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      };

      const handleLengthChange = (e) => {
        setLengthInput(e.target.value);
        const value = parseFloat(e.target.value);
        if (!isNaN(value) && value > 0) {
          setDimensions(prev => ({ ...prev, length: convertToMm(value) }));
        }
      };

      const handleLengthBlur = () => {
        const value = parseFloat(lengthInput);
        if (!isNaN(value) && value > 0) {
          setLengthInput(value.toString());
        } else {
          setLengthInput(convertFromMm(dimensions.length).toString());
        }
      };

      const handleWidthChange = (e) => {
        setWidthInput(e.target.value);
        const value = parseFloat(e.target.value);
        if (!isNaN(value) && value > 0) {
          setDimensions(prev => ({ ...prev, width: convertToMm(value) }));
        }
      };

      const handleWidthBlur = () => {
        const value = parseFloat(widthInput);
        if (!isNaN(value) && value > 0) {
          setWidthInput(value.toString());
        } else {
          setWidthInput(convertFromMm(dimensions.width).toString());
        }
      };

      const handleBridgeWidthChange = (e) => {
        setBridgeWidthInput(e.target.value);
        const value = parseFloat(e.target.value);
        if (!isNaN(value) && value > 0) {
          setAdvancedSettings(prev => ({ ...prev, bridgeWidth: convertToMm(value) }));
        }
      };

      const handleBridgeWidthBlur = () => {
        const value = parseFloat(bridgeWidthInput);
        if (!isNaN(value) && value > 0) {
          setBridgeWidthInput(value.toString());
        } else {
          setBridgeWidthInput(formatUnit(convertFromMm(advancedSettings.bridgeWidth)));
        }
      };

      const handleRowSpacingChange = (e) => {
        setRowSpacingInput(e.target.value);
        const value = parseFloat(e.target.value);
        if (!isNaN(value) && value > 0) {
          setAdvancedSettings(prev => ({ ...prev, rowSpacing: convertToMm(value) }));
        }
      };

      const handleRowSpacingBlur = () => {
        const value = parseFloat(rowSpacingInput);
        if (!isNaN(value) && value > 0) {
          setRowSpacingInput(value.toString());
        } else {
          setRowSpacingInput(formatUnit(convertFromMm(advancedSettings.rowSpacing)));
        }
      };

      const handleCutLengthChange = (e) => {
        setCutLengthInput(e.target.value);
        const value = parseFloat(e.target.value);
        if (!isNaN(value) && value > 0) {
          setAdvancedSettings(prev => ({ ...prev, cutLength: convertToMm(value) }));
        }
      };

      const handleCutLengthBlur = () => {
        const value = parseFloat(cutLengthInput);
        if (!isNaN(value) && value > 0) {
          setCutLengthInput(value.toString());
        } else {
          setCutLengthInput(formatUnit(convertFromMm(advancedSettings.cutLength)));
        }
      };

      const handleKerfWidthChange = (e) => {
        setKerfWidthInput(e.target.value);
        const value = parseFloat(e.target.value);
        if (!isNaN(value) && value > 0) {
          setAdvancedSettings(prev => ({ ...prev, kerfWidth: convertToMm(value) }));
        }
      };

      const handleKerfWidthBlur = () => {
        const value = parseFloat(kerfWidthInput);
        if (!isNaN(value) && value > 0) {
          setKerfWidthInput(value.toString());
        } else {
          setKerfWidthInput(formatUnit(convertFromMm(advancedSettings.kerfWidth)));
        }
      };

      const handleEdgeOverhangChange = (e) => {
        setEdgeOverhangInput(e.target.value);
        const value = parseFloat(e.target.value);
        if (!isNaN(value) && value >= 0) {
          setAdvancedSettings(prev => ({ ...prev, edgeOverhang: convertToMm(value) }));
        }
      };

      const handleEdgeOverhangBlur = () => {
        const value = parseFloat(edgeOverhangInput);
        if (!isNaN(value) && value >= 0) {
          setEdgeOverhangInput(value.toString());
        } else {
          setEdgeOverhangInput(formatUnit(convertFromMm(advancedSettings.edgeOverhang)));
        }
      };

      const { bridgeWidth, rowSpacing, cutLength } = advancedSettings;
      const numRows = Math.floor(dimensions.length / rowSpacing);
      const cutPlusBridge = cutLength + bridgeWidth;
      const numCompleteUnits = Math.floor(dimensions.width / cutPlusBridge);
      const totalCompleteWidth = numCompleteUnits * cutPlusBridge;
      const centerOffset = (dimensions.width - totalCompleteWidth) / 2;

      return (
        <div className="max-w-4xl mx-auto p-6 bg-white">
          <h1 className="text-3xl font-bold text-center mb-8 text-gray-800">Living Hinge Designer</h1>

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <div className="space-y-6">
              <div className="bg-gray-50 p-6 rounded-lg">
                <div className="flex justify-between items-center mb-4">
                  <h2 className="text-xl font-semibold text-gray-700">Dimensions</h2>
                  <div className="flex items-center space-x-2">
                    <label className="text-sm text-gray-600">Units:</label>
                    <select value={units} onChange={(e) => setUnits(e.target.value)} className="px-2 py-1 border border-gray-300 rounded text-sm">
                      <option value="mm">mm</option>
                      <option value="inches">inches</option>
                    </select>
                  </div>
                </div>

                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-600 mb-1">Length (rows direction) ({units})</label>
                    <input type="number" value={lengthInput} onChange={handleLengthChange} onBlur={handleLengthBlur}
                      className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
                      min="1" step={getStepSize()} />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-600 mb-1">Width (cuts direction) ({units})</label>
                    <input type="number" value={widthInput} onChange={handleWidthChange} onBlur={handleWidthBlur}
                      className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
                      min="1" step={getStepSize()} />
                  </div>
                </div>
              </div>

              <div className="bg-gray-50 p-6 rounded-lg">
                <h2 className="text-xl font-semibold mb-4 text-gray-700">Laser Type</h2>
                <div className="space-y-2">
                  <label className="flex items-center">
                    <input type="radio" value="co2" checked={laserType === 'co2'} onChange={(e) => setLaserType(e.target.value)} className="mr-2" />
                    <span>CO2 Laser (0.3mm kerf)</span>
                  </label>
                  <label className="flex items-center">
                    <input type="radio" value="diode" checked={laserType === 'diode'} onChange={(e) => setLaserType(e.target.value)} className="mr-2" />
                    <span>Blue Diode Laser (0.1mm kerf)</span>
                  </label>
                </div>
              </div>

              <div className="bg-gray-50 p-6 rounded-lg">
                <div className="flex justify-between items-center mb-4">
                  <button onClick={() => setShowAdvanced(!showAdvanced)} className="text-lg font-semibold text-gray-700 flex items-center">
                    Advanced Settings <span className="ml-2">{showAdvanced ? '▼' : '▶'}</span>
                  </button>
                  <button
                    onClick={resetToDefaults}
                    className="px-3 py-1 text-sm bg-gray-200 hover:bg-gray-300 text-gray-700 rounded transition-colors">
                    Reset to Defaults
                  </button>
                </div>

                {showAdvanced && (
                  <div className="space-y-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-600 mb-1">Bridge Width ({units})</label>
                      <input type="number" value={bridgeWidthInput}
                        onChange={handleBridgeWidthChange}
                        onBlur={handleBridgeWidthBlur}
                        className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
                        min={units === 'inches' ? 0.001 : 0.1} step={getStepSize()} />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-600 mb-1">Row Spacing ({units})</label>
                      <input type="number" value={rowSpacingInput}
                        onChange={handleRowSpacingChange}
                        onBlur={handleRowSpacingBlur}
                        className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
                        min={units === 'inches' ? 0.01 : 0.5} step={getStepSize()} />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-600 mb-1">Cut Length ({units})</label>
                      <input type="number" value={cutLengthInput}
                        onChange={handleCutLengthChange}
                        onBlur={handleCutLengthBlur}
                        className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
                        min={units === 'inches' ? 0.01 : 1} step={getStepSize()} />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-600 mb-1">Kerf Width ({units})</label>
                      <input type="number" value={kerfWidthInput}
                        onChange={handleKerfWidthChange}
                        onBlur={handleKerfWidthBlur}
                        className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
                        min={units === 'inches' ? 0.001 : 0.05} step={units === 'inches' ? 0.001 : 0.05} />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-600 mb-1">Edge Overhang ({units})</label>
                      <input type="number" value={edgeOverhangInput}
                        onChange={handleEdgeOverhangChange}
                        onBlur={handleEdgeOverhangBlur}
                        className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
                        min="0" step={getStepSize()} />
                      <p className="text-xs text-gray-500 mt-1">How far cuts extend beyond edges (ensures complete cut-through)</p>
                    </div>
                  </div>
                )}
              </div>

              <button onClick={downloadSVG} className="w-full bg-blue-600 text-white py-3 px-6 rounded-lg hover:bg-blue-700 transition-colors font-semibold">
                Download SVG File
              </button>
            </div>

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <h2 className="text-xl font-semibold text-gray-700">Preview</h2>
                <div className="flex items-center space-x-2">
                  <label className="text-sm text-gray-600">Zoom:</label>
                  <select value={zoomLevel} onChange={(e) => setZoomLevel(parseFloat(e.target.value))} className="px-2 py-1 border border-gray-300 rounded text-sm">
                    <option value={0.5}>50%</option>
                    <option value={1}>100%</option>
                    <option value={2}>200%</option>
                    <option value={4}>400%</option>
                    <option value={8}>800%</option>
                  </select>
                </div>
              </div>

              <div className="border border-gray-300 rounded-lg p-4 bg-white overflow-auto" style={{ maxHeight: '500px' }}>
                <div className="relative">
                  <div className="flex justify-center mb-2">
                    <div className="text-xs text-gray-600 bg-blue-100 px-2 py-1 rounded">
                      Width: {formatUnit(convertFromMm(dimensions.width))}{units}
                    </div>
                  </div>

                  <div className="flex items-center">
                    <div className="mr-2 flex items-center justify-center" style={{ height: dimensions.length * zoomLevel + 'px', minHeight: '200px' }}>
                      <div className="text-xs text-gray-600 bg-blue-100 px-2 py-1 rounded transform -rotate-90 whitespace-nowrap">
                        Length: {formatUnit(convertFromMm(dimensions.length))}{units}
                      </div>
                    </div>

                    <div className="relative">
                      <div className="relative" style={{
                        width: dimensions.width * zoomLevel + 'px', height: dimensions.length * zoomLevel + 'px',
                        minWidth: '100px', minHeight: '100px', border: '4px solid #3b82f6', backgroundColor: 'white'
                      }}>
                        <div className="absolute -top-2 -left-2 w-4 h-4 bg-blue-500 rounded-full" />
                        <div className="absolute -top-2 -right-2 w-4 h-4 bg-blue-500 rounded-full" />
                        <div className="absolute -bottom-2 -left-2 w-4 h-4 bg-blue-500 rounded-full" />
                        <div className="absolute -bottom-2 -right-2 w-4 h-4 bg-blue-500 rounded-full" />

                        <svg width="100%" height="100%" viewBox={'0 0 ' + dimensions.width + ' ' + dimensions.length} className="block" style={{ background: '#f3e5ab' }}>
                          <defs>
                            <style>{'.cut-line { stroke: #dc2626; stroke-width: ' + Math.max(advancedSettings.kerfWidth, 0.05) + '; fill: none; }'}</style>
                          </defs>

                          <g id="living-hinge-pattern">
                            {(() => {
                              const lines = [];
                              for (let row = 0; row < numRows; row++) {
                                const y = row * rowSpacing;
                                const isEvenRow = row % 2 === 0;
                                const brickOffset = isEvenRow ? 0 : cutPlusBridge / 2;
                                const startX = centerOffset + brickOffset;

                                let cutIndex = 0;
                                for (let x = startX - cutPlusBridge; x < dimensions.width + cutPlusBridge; x += cutPlusBridge) {
                                  const x1 = x;
                                  const x2 = x + cutLength;

                                  if (x2 > 0 && x1 < dimensions.width) {
                                    lines.push(<line key={row + '-' + cutIndex} x1={x1} y1={y} x2={x2} y2={y} className="cut-line" />);
                                  }
                                  cutIndex++;
                                }
                              }
                              return lines;
                            })()}
                          </g>
                        </svg>
                      </div>

                      <div className="mt-2 text-xs text-gray-500 text-center">
                        Zoom: {zoomLevel * 100}% | Blue frame = exact {formatUnit(convertFromMm(dimensions.width))}×{formatUnit(convertFromMm(dimensions.length))}{units} dimensions
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div className="text-sm text-gray-600 space-y-1">
                <p><strong>Pattern Info:</strong></p>
                <p>• Rows: {numRows}</p>
                <p>• Cuts span full width (partial cuts allowed at edges)</p>
                <p>• Pattern: Standard kerf (offset brick)</p>
                <p>• Based on {formatUnit(convertFromMm(advancedSettings.rowSpacing))}{units} row spacing test results</p>
              </div>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<LivingHingeGenerator />, document.getElementById('root'));
  </script>
</body>

</html>